#!/usr/bin/env bash

set -Eeuo pipefail

die() { echo "$1" 1>&2; exit 1; }

# Required env vars.
[ -n "${BIN_NAME:-}" ] || die "Must set BIN_NAME"
[ -n "${VERSION:-}" ] || die "Must set VERSION"
[ -n "${REVISION:-}" ] || die "Must set REVISION"
[ -n "${DOCKERFILE:-}" ] || die "Must set DOCKERFILE"
[ -n "${TARGET:-}" ] || die "Must set TARGET"
[ -n "${AUTO_TAG:-}" ] || die "Must set AUTO_TAG"
[ -n "${TAGS:-}${REDHAT_TAG:-}" ] || die "Must set either TAG or REDHAT_TAG"

# --- CONDITIONAL REQUIRED MODE SELECTION ---
if [[ -n "${PLATFORMS:-}" ]]; then
    BUILD_MODE="manifest"
elif [[ -n "${PLATFORM:-}" ]]; then
    BUILD_MODE="tarball"
else
    die "Must set either PLATFORM (for 'tarball' build mode) or PLATFORMS (for 'manifest' multi-arch mode)"
fi
# --- END NEW REQUIRED ENV VARS ---

WORKDIR="${WORKDIR:-.}"

export DEV_TAGS="${DEV_TAGS:-}"
export REDHAT_TAG="${REDHAT_TAG:-}"
export EXTRA_BUILD_ARGS="${EXTRA_BUILD_ARGS:-}"
export SSH_PRIVATE_KEY="${SSH_PRIVATE_KEY:-}"

# Convert all contiguous blocks of whitespace to single spaces using xargs.
# This is needed to get all tags on one line for the read -ra below.
PROD_TAGS="$(xargs <<< "$TAGS")"
DEV_TAGS="$(xargs <<< "$DEV_TAGS")"

read -ra DEV_TAGS_A <<< "$DEV_TAGS"
read -ra PROD_TAGS_A <<< "$PROD_TAGS"

# ALL_TAGS will contain all tags relevant to the current build, regardless of mode.
# For manifest mode, these will all be pushed with the multi-arch manifest.
# For tarball mode, these will be used for local saving and validation.
ALL_TAGS=("${DEV_TAGS_A[@]}")
ALL_TAGS+=("$AUTO_TAG")
ALL_TAGS+=("${PROD_TAGS_A[@]}")
if [ -n "$REDHAT_TAG" ]; then
	ALL_TAGS+=("${REDHAT_TAG}")
fi
echo "ALL_TAGS:" "${ALL_TAGS[@]}"


# TAG_FLAGS array is perfect for passing to buildx --tag (or docker build --tag)
for T in "${ALL_TAGS[@]}"; do
	TAG_FLAGS+=("--tag=$T")
done

BUILD_ARGS=("BIN_NAME=$BIN_NAME")
BUILD_ARGS+=("PRODUCT_VERSION=$VERSION")
BUILD_ARGS+=("PRODUCT_REVISION=$REVISION")

for B in "${BUILD_ARGS[@]}"; do
	BA_FLAGS+=("--build-arg=$B")
done

# Append any extra build args to the final list of build args.
if [ -n "$EXTRA_BUILD_ARGS" ]; then
  # Convert all contiguous blocks of whitespace to single spaces using xargs.
  # This is needed to get all tags on one line for the read -ra below.
  EXTRA_BUILD_ARGS="$(xargs <<<"$EXTRA_BUILD_ARGS")"

  read -ra EXTRA_BUILD_ARGS_A <<<"$EXTRA_BUILD_ARGS"
  for E in "${EXTRA_BUILD_ARGS_A[@]}"; do
    BA_FLAGS+=("--build-arg=$E")
  done
fi

if [[ "$OS" == "windows" ]]; then
  # Warning: Our Dockerfiles refer to TARGETOS and TARGETARCH.
  # They claim it's set "automatically when --platform is provided."
  # Lies.
  # Maybe that's a buildx feature, because build doesn't. So we need to manually inject it.
  # Note: For buildx in manifest mode, TARGETOS/ARCH are handled correctly by --platform.
  # This block is only relevant for the `docker build` fallback or if platform specific args are needed.
  BA_FLAGS+=(
    "--build-arg=TARGETOS=${OS}"
    "--build-arg=TARGETARCH=${PLATFORM#*/}"
  )
fi

# Check if the SSH_PRIVATE_KEY variable is set and non-empty
if [ -n "$SSH_PRIVATE_KEY" ]; then
  ssh_option="default"
  SSH_FLAG=("--ssh=${ssh_option}")  # Set SSH flag to use default agent
else
  SSH_FLAG=()  # If SSH_PRIVATE_KEY is not set, leave SSH_FLAG empty
fi

# These paths are only relevant for 'tarball' mode
TARBALL_PATH="$PWD/$TARBALL_NAME"
DEV_TARBALL_PATH="$PWD/$DEV_TARBALL_NAME"
REDHAT_TARBALL_PATH="$PWD/$REDHAT_TARBALL_NAME"

cd "$WORKDIR"


echo "==> Building image with tags:"
for T in "${ALL_TAGS[@]}"; do
  echo "    - $T"
done

# --- Main Conditional Build Logic based on BUILD_MODE ---

if [[ "$BUILD_MODE" == "manifest" ]]; then
    echo "==> Entering Manifest Build Mode: Building and pushing multi-architecture manifest."

    # Your existing `docker buildx create --use` for Linux.
    # It's good that it's here, as it ensures the builder is active.
    # Note: docker/setup-buildx-action in action.yml usually handles this for robustness.
    if [[ "$OS" == "linux" ]]; then
      docker buildx create --use
    fi

    # Build and push the multi-architecture image and manifest
    docker buildx build --push \
      --target "$TARGET" \
      --platform "$PLATFORMS" \
      "${SSH_FLAG[@]}" \
      "${TAG_FLAGS[@]}" \
      "${BA_FLAGS[@]}" \
      -f "$DOCKERFILE" \
      .

    echo "==> Multi-architecture manifest pushed successfully to registry."

    # --- Handling version_label_validation for manifest mode ---
    # This function expects a locally loaded image for `docker inspect`.
    # When using `buildx build --push`, the image is NOT loaded locally.
    # Alternatively we can use skopeo to inspect images remotely
    # skopeo inspect docker://docker.io/hashicorp/$product:$version --raw | jq '.manifests[].digest'
    # loop over the checksums and verify the version label for each architecture
    # skopeo inspect "docker://docker.io/hashicorp/$product@${digest}" | jq ".Labels"
    # this was validated against dockerhub but requires validation against other registries as well.
    echo "Note: Local version label validation is skipped in 'manifest' build mode as image is directly pushed."

    # Exit the script here to skip the tarball-specific saving steps
    exit 0

elif [[ "$BUILD_MODE" == "tarball" ]]; then
    echo "==> Entering Tarball Build Mode: Building single-architecture image and saving as tarball."

    if [[ "$OS" == "linux" ]]; then
        # Your existing buildx build --load logic for Linux
        docker buildx create --use # Ensure builder is used for this path too
        docker buildx build --load \
          --target "$TARGET" \
          --platform "$PLATFORM" \
          "${SSH_FLAG[@]}" \
          "${TAG_FLAGS[@]}" \
          "${BA_FLAGS[@]}" \
          -f "$DOCKERFILE" \
          .
    else
        # Your existing non-Linux docker build logic
        (set -x;
        docker build \
          --target "$TARGET" \
          --platform "$PLATFORM" \
          "${TAG_FLAGS[@]}" \
          "${BA_FLAGS[@]}" \
          -f "$DOCKERFILE" \
          .
        )
    fi

    # --- Version label validation (remains as is for tarball mode) ---
    # This relies on the image being loaded locally, which it is in this mode.
    version_label_validation() {
        val=$(docker inspect --format='{{ index .Config.Labels "version" }}' "${2}")
        error_context="actions-docker-build passes a 'PRODUCT_VERSION' build-arg to the build. Ensure it is defined in the Dockerfile and the 'version' label uses it"
        if [ "$val" = "" ]; then
            die "Error: 'version' label must be set to version passed in but was empty.\n$error_context"
        elif [ "$val" != "${1}" ]; then
            die "Error: 'version' label must match the version passed in but was ($val).\n$error_context"
        fi
    }
    for T in "${ALL_TAGS[@]}"; do
        version_label_validation "$VERSION" "$T"
    done

    # --- Existing docker save commands (remains as is for tarball mode) ---
    echo "==> Saving prod tags in '$TARBALL_PATH'"
    # Note: docker save requires specific tags that are loaded locally.
    # "${PROD_TAGS_A[@]}" and "$AUTO_TAG" must be among the tags loaded by the build command.
    docker save --output "$TARBALL_PATH" "${PROD_TAGS_A[@]}" "$AUTO_TAG"
    echo "==> Tarball created."
    ls -lah "$TARBALL_PATH"

    if [ -n "$DEV_TAGS" ]; then
        echo "==> Saving dev tags in '$DEV_TARBALL_PATH'"
        docker save --output "$DEV_TARBALL_PATH" "${DEV_TAGS_A[@]}" "$AUTO_TAG"
        echo "==> Dev Tarball created."
        ls -lah "$DEV_TARBALL_PATH"
    else
        echo "==> No dev tags specified, skipping export."
    fi

    if [ -n "$REDHAT_TAG" ]; then
        echo "==> Saving Redhat tag '$REDHAT_TAG' to '$REDHAT_TARBALL_PATH'"
        docker save --output "$REDHAT_TARBALL_PATH" "${REDHAT_TAG}" "$AUTO_TAG"
        echo "==> Redhat Tarball created."
        ls -lah "$REDHAT_TARBALL_PATH"
    else
        echo "==> No Redhat tag specified, skipping export."
    fi

else
    die "Error: Invalid BUILD_MODE '${BUILD_MODE}'. Must be 'manifest' or 'tarball'."
fi
